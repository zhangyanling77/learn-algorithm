# 面试中的算法

## 一、如何判断链表有环

方法一：

从头节点开始，依次遍历单链表中的每一个节点。每遍历一个新节点，就从头检查新节点之前的所有的节点，用新节点和之前的所有节点依次做比较。如果发现节点和之前的某个节点相同，则说明这个节点被遍历过了，链表有环，否则没有环。

时间复杂度 O(n<sup>2</sup>)，空间复杂度 O(1)。

方法二：

创建以节点ID为key的HashSet集合，用于存储遍历过的节点。从头节点开始，依次遍历每一个节点。每遍历一个新节点就和HashSet集合中存储的节点对比，如果存在相同的节点，则证明链表有环，否则将该节点存入HashSet中，继续下一个节点重复之前的操作。

时间复杂度 O(n)，空间复杂度 O(n)。

方法三：

创建两个指针p1、p2，让他们同时指向链表的头节点。然后开始一个大循环，循环体中，p1每次向后移动1个节点，p2每次向后移动两个节点，然后比较两个节点是否相同。相同表示链表有环，否则进入下一次循环。

时间复杂度 O(n)，空间复杂度 O(1)。（最优）

```javascript
class Node {
  constructor(data) {
    this.data = data
    this.next = null
  }
}

function isCircle(head) {
  let p1 = head;
  let p2 = head;
  while(p2 !== null && p2.next !== null) {
    p1 = p1.next;
    p2 = p2.next.next;
    if (p1 === p1) {
      return true
    }
  }
  return false;
}

let node1 = new Node(5);
let node2 = new Node(3);
let node3 = new Node(7);
let node4 = new Node(2);
let node5 = new Node(6);

node1.next = node2;
node2.next = node3;
node3.next = node4;
node4.next = node5;
node5.next = node2;

console.log(isCircle(node1)) // true
```

问题扩展：

- 如果链表有环，如何求出环的长度？

  当指针首次相遇，表示链表有环的时候，让两个指针从相遇点继续循环前进，并统计前进的循环次数，直到两个指针再次相遇。此时前进的次数就是环的长度。

  环长 = 第一次速度差 x 前进次数 = 前进次数

- 如果链表有环，如何求出入环节点？

  从链表头节点到入环点的举里，等于首次相遇点绕 n - 1 圈再回到入环点的距离。

  D = (n - 1) x (S<sub>1</sub> + S<sub>2</sub>) + S<sub>2</sub>

  注意：S<sub>1</sub> 表示从入环点到两个指针首次相遇点的距离；S<sub>2</sub> 表示从首次相遇点回到入环点的距离。

## 二、最小栈的实现

问题：实现一个栈，该栈带有出栈（pop）、入栈（push）、取最小元素（getMin）3个方法。

要求：要保证三个方法的时间复杂度为 O(1)

解法步骤如下：

1.创建一个主栈A，备用栈B，用于辅助A。

2.当第一个元素进入A，让新元素也进入B。这个唯一的元素是栈A的当前最小值。

3.之后，每当新元素进入栈A，比较元素和栈A当前最小值的大小，如果小于栈A当前的最小值，就让新元素进入栈B。此时栈B的栈顶元素即为栈A当前的最小值。

4.每当栈A有元素出栈时，如果出栈元素是栈A当前最小值，则让栈B的栈顶元素也出栈。

5.当调用getMin方法时，返回栈B的栈顶元素即可。

该解法，入栈、出栈、取最小值的时间复杂度均为 O(1)，最坏空间复杂度为 O(n)。

```javascript
// ... Stack 类之前已经实现过了，略过

class MinStack {
  constructor() {
    this.mainStack = new Stack();
    this.minStack = new Stack();
  }
  // 入栈
  push(element) {
    this.mainStack.push(element);
    // 如果辅助栈为空，或者新元素小于或等于辅助栈栈顶，则将新元素压入辅助栈
    if (this.minStack.empty() || element < this.minStack.peek()) {
      this.minStack.push(element);
    }
  }
  // 出栈
  pop() {
    // 如出栈元素和辅助栈栈顶元素相等，辅助栈出栈
    if (this.minStack.peek() === this.mainStack.peek()) {
      this.minStack.pop();
    }
    return this.mainStack.pop();
  }
  // 获取栈最小元素
  getMin() {
    if (this.mainStack.empty()) {
      throw new Error('stack is empty!')
    }
    return this.minStack.peek();
  }
}

let stack = new MinStack();
stack.push(4)
stack.push(9)
stack.push(7)
stack.push(3)
stack.push(8)
stack.push(5)
console.log(stack.getMin()) // 3
stack.pop()
stack.pop()
stack.pop()
console.log(stack.getMin()) // 4

```

## 三、如何求出最大公约数

## 四、如何判断一个数是否为2的整数次幂

## 五、无序数组排序后的最大相邻差

## 六、如何用栈实现队列

## 七、寻找全排列的下一个数

## 八、删去k个数字后的最小值

## 九、如何实现大整数相加

## 十、如何求解金矿问题

## 十一、寻找缺失的整数

