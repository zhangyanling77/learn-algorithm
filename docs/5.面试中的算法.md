# 面试中的算法

## 一、如何判断链表有环

方法一：

从头节点开始，依次遍历单链表中的每一个节点。每遍历一个新节点，就从头检查新节点之前的所有的节点，用新节点和之前的所有节点依次做比较。如果发现节点和之前的某个节点相同，则说明这个节点被遍历过了，链表有环，否则没有环。

时间复杂度 O(n<sup>2</sup>)，空间复杂度 O(1)。

方法二：

创建以节点ID为key的HashSet集合，用于存储遍历过的节点。从头节点开始，依次遍历每一个节点。每遍历一个新节点就和HashSet集合中存储的节点对比，如果存在相同的节点，则证明链表有环，否则将该节点存入HashSet中，继续下一个节点重复之前的操作。

时间复杂度 O(n)，空间复杂度 O(n)。

方法三：

创建两个指针p1、p2，让他们同时指向链表的头节点。然后开始一个大循环，循环体中，p1每次向后移动1个节点，p2每次向后移动两个节点，然后比较两个节点是否相同。相同表示链表有环，否则进入下一次循环。

时间复杂度 O(n)，空间复杂度 O(1)。（最优）

```javascript
class Node {
  constructor(data) {
    this.data = data
    this.next = null
  }
}

function isCircle(head) {
  let p1 = head;
  let p2 = head;
  while(p2 !== null && p2.next !== null) {
    p1 = p1.next;
    p2 = p2.next.next;
    if (p1 === p1) {
      return true
    }
  }
  return false;
}

let node1 = new Node(5);
let node2 = new Node(3);
let node3 = new Node(7);
let node4 = new Node(2);
let node5 = new Node(6);

node1.next = node2;
node2.next = node3;
node3.next = node4;
node4.next = node5;
node5.next = node2;

console.log(isCircle(node1)) // true
```

## 二、最小栈的实现

## 三、如何求出最大公约数

## 四、如何判断一个数是否为2的整数次幂

## 五、无序数组排序后的最大相邻差

## 六、如何用栈实现队列

## 七、寻找全排列的下一个数

## 八、删去k个数字后的最小值

## 九、如何实现大整数相加

## 十、如何求解金矿问题

## 十一、寻找缺失的整数

