# 面试中的算法

## 一、如何判断链表有环

方法一：

从头节点开始，依次遍历单链表中的每一个节点。每遍历一个新节点，就从头检查新节点之前的所有的节点，用新节点和之前的所有节点依次做比较。如果发现节点和之前的某个节点相同，则说明这个节点被遍历过了，链表有环，否则没有环。

时间复杂度 O(n<sup>2</sup>)，空间复杂度 O(1)。

方法二：

创建以节点ID为key的HashSet集合，用于存储遍历过的节点。从头节点开始，依次遍历每一个节点。每遍历一个新节点就和HashSet集合中存储的节点对比，如果存在相同的节点，则证明链表有环，否则将该节点存入HashSet中，继续下一个节点重复之前的操作。

时间复杂度 O(n)，空间复杂度 O(n)。

方法三：

创建两个指针p1、p2，让他们同时指向链表的头节点。然后开始一个大循环，循环体中，p1每次向后移动1个节点，p2每次向后移动两个节点，然后比较两个节点是否相同。相同表示链表有环，否则进入下一次循环。

时间复杂度 O(n)，空间复杂度 O(1)。（最优）

```javascript
class Node {
  constructor(data) {
    this.data = data
    this.next = null
  }
}

function isCircle(head) {
  let p1 = head;
  let p2 = head;
  while(p2 !== null && p2.next !== null) {
    p1 = p1.next;
    p2 = p2.next.next;
    if (p1 === p1) {
      return true
    }
  }
  return false;
}

let node1 = new Node(5);
let node2 = new Node(3);
let node3 = new Node(7);
let node4 = new Node(2);
let node5 = new Node(6);

node1.next = node2;
node2.next = node3;
node3.next = node4;
node4.next = node5;
node5.next = node2;

console.log(isCircle(node1)) // true
```

问题扩展：

- 如果链表有环，如何求出环的长度？

  当指针首次相遇，表示链表有环的时候，让两个指针从相遇点继续循环前进，并统计前进的循环次数，直到两个指针再次相遇。此时前进的次数就是环的长度。

  环长 = 第一次速度差 x 前进次数 = 前进次数

- 如果链表有环，如何求出入环节点？

  从链表头节点到入环点的举里，等于首次相遇点绕 n - 1 圈再回到入环点的距离。

  D = (n - 1) x (S<sub>1</sub> + S<sub>2</sub>) + S<sub>2</sub>

  注意：S<sub>1</sub> 表示从入环点到两个指针首次相遇点的距离；S<sub>2</sub> 表示从首次相遇点回到入环点的距离。

## 二、最小栈的实现

问题：实现一个栈，该栈带有出栈（pop）、入栈（push）、取最小元素（getMin）3个方法。

要求：要保证三个方法的时间复杂度为 O(1)

解法步骤如下：

1.创建一个主栈A，备用栈B，用于辅助A。

2.当第一个元素进入A，让新元素也进入B。这个唯一的元素是栈A的当前最小值。

3.之后，每当新元素进入栈A，比较元素和栈A当前最小值的大小，如果小于栈A当前的最小值，就让新元素进入栈B。此时栈B的栈顶元素即为栈A当前的最小值。

4.每当栈A有元素出栈时，如果出栈元素是栈A当前最小值，则让栈B的栈顶元素也出栈。

5.当调用getMin方法时，返回栈B的栈顶元素即可。

该解法，入栈、出栈、取最小值的时间复杂度均为 O(1)，最坏空间复杂度为 O(n)。

```javascript
// ... Stack 类之前已经实现过了，略过

class MinStack {
  constructor() {
    this.mainStack = new Stack();
    this.minStack = new Stack();
  }
  // 入栈
  push(element) {
    this.mainStack.push(element);
    // 如果辅助栈为空，或者新元素小于或等于辅助栈栈顶，则将新元素压入辅助栈
    if (this.minStack.empty() || element < this.minStack.peek()) {
      this.minStack.push(element);
    }
  }
  // 出栈
  pop() {
    // 如出栈元素和辅助栈栈顶元素相等，辅助栈出栈
    if (this.minStack.peek() === this.mainStack.peek()) {
      this.minStack.pop();
    }
    return this.mainStack.pop();
  }
  // 获取栈最小元素
  getMin() {
    if (this.mainStack.empty()) {
      throw new Error('stack is empty!')
    }
    return this.minStack.peek();
  }
}

let stack = new MinStack();
stack.push(4)
stack.push(9)
stack.push(7)
stack.push(3)
stack.push(8)
stack.push(5)
console.log(stack.getMin()) // 3
stack.pop()
stack.pop()
stack.pop()
console.log(stack.getMin()) // 4
```

## 三、如何求出最大公约数

- 辗转相除法

辗转相除法，又名欧几里得算法，该算法的目的是求出两个正整数的最大公约数。

该算法基于一个定理：**两个正整数a和b（a>b），它们的最大公约数等于a除以b的余数c和b之间的最大公约数**。

因此，我们可以使用递归的方法来解这个问题，逐渐把两个较大整数之间的运算简化成两个较小整数之间的运算，直到两个数可以整除，或者其中一个数减小为1为止。

```javascript
function getGreatestCommonDivisor(a, b) {
  let big = a > b ? a : b;
  let small = a < b ? a : b;
  if (big % small === 0) {
    return small;
  }
  return getGreatestCommonDivisor(big%small, small);
}

console.log(getGreatestCommonDivisor(25, 5)) // 5
console.log(getGreatestCommonDivisor(100, 80)) // 20
console.log(getGreatestCommonDivisor(27, 14)) // 1
```
时间复杂度为 O(log(max(a,b)))

- 更相减损术

原理：**两个正整数a和b（a>b），它们的最大公约数等于a-b的差值c和较小数b的最大公约数**。

同样的，我们也可以用递归来解决这个问题，逐渐把两个较大整数之间的运算简化成两个较小整数之间的运算，直到两个数可以相等为止，最大公约数就是最终相等的这两个数。

```javascript
function getGreatestCommonDivisor(a, b) {
  if (a === b) {
    return a;
  }
  let big = a > b ? a : b;
  let small = a < b ? a : b;
  return getGreatestCommonDivisor(big-small, small)
}

console.log(getGreatestCommonDivisor(25, 5)) // 5
console.log(getGreatestCommonDivisor(100, 80)) // 20
console.log(getGreatestCommonDivisor(27, 14)) // 1
```
时间复杂度为 O(max(a,b))

- 结合辗转相除法和更相减损术，在更相减损术基础上使用移位运算

思路：

> gcd即getGreatestCommonDivisor方法简称。

1.当a和b均为偶数时，gcd(a, b) = 2 x gcd(a/2, b/2) = 2 x gcd(a>>1, b>>1)

2.当a为偶数，b为奇数，gcd(a, b) = gcd(a/2, b) = gcd(a>>1, b)

3.当a为奇数，b为偶数，gcd(a, b) = gcd(a, b/2) = gcd(a, b>>1)

4.当a和b均为奇数时，先利用更相减损术运算一次，gcd(a, b) = gcd(b, a - b)，此时a-b必然为偶数，然后再继续进行移位运算。

```javascript
function getGreatestCommonDivisor(a, b) {
  if (a === b) {
    return a;
  }
  if ((a & 1) ===0 && (b & 1) === 0) { // a、b均为偶数
    return getGreatestCommonDivisor(a>>1, b>>1)<<1;
  } else if ((a & 1)===0 && (b & 1) !== 0) { // a偶 b奇
    return getGreatestCommonDivisor(a>>1, b)
  } else if ((a & 1) !==0 && (b & 1) === 0) { // a奇 b偶
    return getGreatestCommonDivisor(a, b>>1)
  } else { // a、b均为奇数
    let big = a > b ? a : b;
    let small = a < b ? a : b;
    return getGreatestCommonDivisor(big-small, small)
  }
}

console.log(getGreatestCommonDivisor(25, 5)) // 5
console.log(getGreatestCommonDivisor(100, 80)) // 20
console.log(getGreatestCommonDivisor(27, 14)) // 1
```
时间复杂度为 O(log(max(a,b)))

## 四、如何判断一个数是否为2的整数次幂

## 五、无序数组排序后的最大相邻差

## 六、如何用栈实现队列

## 七、寻找全排列的下一个数

## 八、删去k个数字后的最小值

## 九、如何实现大整数相加

## 十、如何求解金矿问题

## 十一、寻找缺失的整数

