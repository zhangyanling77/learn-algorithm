# 排序算法

根据时间复杂度的不同，主流排序算法可以分为3类。

1.时间复杂度为 O(n<sup>2</sup>) 的排序算法。

- 冒泡排序

- 选择排序

- 插入排序

- 希尔排序（它的性能优于 O(n<sup>2</sup>) ，但又比不上 O(nlogn)。

2.时间复杂度为 O(nlogn) 的排序算法。

- 快速排序

- 归并排序

- 堆排序

3.时间复杂度为线性 O(n) 的排序。

- 计数排序

- 桶排序

- 基数排序

此外，还可以根据其算法的稳定性分为，**稳定排序**和**不稳定排序**。即，如果值相同的元素在排序后仍然保持着排序前的顺序，则稳定；如果值相同的元素在排序后打乱了排序前的顺序，则不稳定。

排序算法 | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 | 是否稳定排序
:-|:-|:-|:-|:-
冒泡排序 | O(n<sup>2</sup>) | O(n<sup>2</sup>) | O(1) | 稳定
选择排序 | O(n<sup>2</sup>) | O(n<sup>2</sup>) | O(1) | 不稳定
插入排序 | O(n<sup>2</sup>) | O(n<sup>2</sup>) | O(1) | 稳定
希尔排序 | O(nlogn) ~ O(n<sup>2</sup>) | O(n<sup>2</sup>) | O(1) | 不稳定
快速排序 | O(nlogn) | O(n<sup>2</sup>) | O(nlogn) | 不稳定
归并排序 | O(nlogn) | O(nlogn) | O(n) | 稳定
堆排序 | O(nlogn) | O(nlogn) | O(1) | 不稳定
计数排序 | O(n + m) | O(n + m) | O(m) | 稳定
桶排序 | O(n + m) | O(n<sup>2</sup>) | O(n + m) | 稳定
基数排序 | O(nm) | O(nm) | O(n + m) | 稳定

## 冒泡排序

冒泡排序（bubble sort），是一种基础的交换排序。

思想：将相邻的元素两两比较，当一个元素大于右侧相邻元素时，交换它们的位置；当一个元素小于或等于右侧相邻元素时，位置不变。

冒泡排序是一种稳定排序。由于该排序算法的每一轮都要遍历所有元素，总共遍历（元素数量 - 1）轮，所以平均时间复杂度为 O(n<sup>2</sup>)。

代码实现：

```javascript
function sort(array) {
  for (let i = 0; i < array.length - 1; i++) {
    for (let j = 0; j < array.length - 1 - i; j++) {
      let tmp = 0;
      if (array[j] > array[j+1]) {
        tmp = array[j]
        array[j] = array[j+1]
        array[j+1] = tmp
      }
    }
  }
}

function output() {
  for (let i = 0; i < array.length; i++) {
    console.log(array[i])
  }
}

const array = [5, 8, 6, 3, 9, 2, 1, 7];

sort(array)

output() // 1 2 3 5 6 7 8 9
```

## 快速排序

快速排序也属于交换排序，与冒泡排序不同的是，在每一轮挑选一个基准元素，并让其他比它大的元素移动到数列一边，比它小的元素移动到数列的另一边，从而把数列拆解成两个部分。这种思路叫做**分治法**。

在分治法的思想下，原属列在每一轮都被拆成两部分，每一部分在下一轮又分别被拆成两部分，直到不可再分为止。每一轮的比较和交换需要把全部元素都遍历一遍，因此快速排序的时间复杂度为 O(nlogn)。

### 基准元素的选择

基准元素（pivot），在分治的过程中，以基准元素为中心，把其他元素移动到它的左右两边。

最简单的确定基准元素的方式是选择数列的第1个元素。但是在特殊的情况下，会存在问题，解决的办法是随机选择一个元素作为基准元素，并且让基准元素和数列首元素交换位置。

### 元素的交换

选定好基准元素后，把其他元素中小于它的都交换到它的一边，大于它的都交换到它的另一边。具体实现有两种方法。

1.双边循环法

2.单边循环法

## 堆排序


## 计数排序


## 桶排序


